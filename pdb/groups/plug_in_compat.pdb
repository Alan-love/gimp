# GIMP - The GNU Image Manipulation Program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>


# The declared ranges generate min/max in GParamSpecs
# and the min becomes the default in the GParamSpecs.
# A declared range must correspond with range declared in GEGL
# else args defaulted from min may generate out-of-range warnings.

sub plug_in_autocrop {
    $blurb = 'Remove empty borders from the image';

    $help = <<'HELP';
Remove empty borders from the image.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image',
	  desc => 'Input image)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error))
    {
      gint x, y, width, height;
      gint off_x, off_y;

      gimp_pickable_auto_shrink (GIMP_PICKABLE (drawable),
                                 0, 0,
                                 gimp_item_get_width  (GIMP_ITEM (drawable)),
                                 gimp_item_get_height (GIMP_ITEM (drawable)),
                                 &x, &y, &width, &height);

      gimp_item_get_offset (GIMP_ITEM (drawable), &off_x, &off_y);
      x += off_x;
      y += off_y;

      gimp_image_undo_group_start (image, GIMP_UNDO_GROUP_ITEM_RESIZE,
                                   _("Autocrop image"));

      if (x          < 0                             ||
          y          < 0                             ||
          x + width  > gimp_image_get_width  (image) ||
          y + height > gimp_image_get_height (image))
        {
          /*
           * partially outside the image area, we need to
           * resize the image to be able to crop properly.
           */
          gimp_image_resize (image, context, width, height, -x, -y, NULL);

          x = y = 0;
        }

      gimp_image_crop (image, context, GIMP_FILL_TRANSPARENT,
                       x, y, width, height, TRUE);

      gimp_image_undo_group_end (image);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_autocrop_layer {
    $blurb = 'Crop the selected layers based on empty borders of the input drawable';

    $help = <<'HELP';
Crop the selected layers of the input "image" based on empty borders of the input "drawable".
\n\nThe input drawable serves as a base for detecting cropping extents (transparency or background color), and is not necessarily among the cropped layers (the current selected layers).
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image',
	  desc => 'Input image)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error))
    {
      GList *layers = gimp_image_get_selected_layers (image);
      GList *iter;
      gint   x, y, width, height;

      if (layers)
        {
          switch (gimp_pickable_auto_shrink (GIMP_PICKABLE (drawable),
                                             0, 0,
                                             gimp_item_get_width  (GIMP_ITEM (drawable)),
                                             gimp_item_get_height (GIMP_ITEM (drawable)),
                                             &x, &y, &width, &height))
            {
            case GIMP_AUTO_SHRINK_SHRINK:
              gimp_image_undo_group_start (image, GIMP_UNDO_GROUP_ITEM_RESIZE,
                                           _("Autocrop layer"));

              for (iter = layers; iter; iter = iter->next)
                  gimp_item_resize (GIMP_ITEM (iter->data),
                                    context, GIMP_FILL_TRANSPARENT,
                                    width, height, -x, -y);

              gimp_image_undo_group_end (image);
	      break;

	    default:
	      break;
            }
	}
      else
        {
          success = FALSE;
        }
    }
  else
    {
      success = FALSE;
    }
}
CODE
    );
}

sub plug_in_bump_map {
    $blurb = 'Create an embossing effect using a bump map';

    $help = <<'HELP';
This plug-in uses the algorithm described by John Schlag,
"Fast Embossing Effects on Raster Image Data" in
Graphics GEMS IV (ISBN 0-12-336155-9).
It takes a drawable to be applied as a bump
map to another image and produces a nice embossing effect.
HELP

    &std_pdb_compat('gegl:bump-map');
    $date = '2015';

    @inargs = (
  { name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
    desc => 'The run mode' },
  { name => 'image', type => 'image', dead => 1,
    desc => 'Input image (unused)' },
  { name => 'drawable', type => 'drawable',
    desc => 'Input drawable' },
  { name => 'bumpmap', type => 'drawable',
    desc => 'Bump map drawable' },
  { name => 'azimuth', type => '0.0 <= double <= 360.0',
    desc => 'Azimuth' },
  { name => 'elevation', type => '0.5 <= double <= 90.0',
    desc => 'Elevation' },
  { name => 'depth', type => '1 <= int32 <= 65',
    desc => 'Depth' },
  { name => 'xofs', type => 'int32',
    desc => 'X offset' },
  { name => 'yofs', type => 'int32',
    desc => 'Y offset' },
  { name => 'waterlevel', type => '0.0 <= double <= 1.0',
    desc => 'Level that full transparency should represent' },
  { name => 'ambient', type => '0.0 <= double <= 1.0',
    desc => 'Ambient lighting factor' },
  { name => 'compensate', type => 'boolean',
    desc => 'Compensate for darkening' },
  { name => 'invert', type => 'boolean',
    desc => 'Invert bumpmap' },
  { name => 'type', type => '0 <= int32 <= 3',
    desc => 'Type of map { LINEAR (0), SPHERICAL (1), SINUSOIDAL (2) }' }
    );

    %invoke = (
  code => <<'CODE'
{
  success = bump_map (drawable,
                      bumpmap,
                      azimuth,
                      elevation,
                      depth,
                      xofs,
                      yofs,
                      waterlevel,
                      ambient,
                      compensate,
                      invert,
                      type,
                      FALSE,
                      progress,
                      error);
}
CODE
    );
}

sub plug_in_cubism {
    $blurb = 'Convert the image into randomly rotated square blobs';

    $help = <<'HELP';
Convert the image into randomly rotated square blobs.
HELP

    &std_pdb_compat('gegl:cubism');
    $date = '2013';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image', dead => 1,
	  desc => 'Input image (unused)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' },
	{ name => 'tile_size', type => '0.0 <= double <= 100.0',
	  desc => 'Average diameter of each tile (in pixels)' },
	{ name => 'tile_saturation', type => '0.0 <= double <= 10.0',
	  desc => 'Expand tiles by this amount' },
	{ name => 'bg_color', type => '0 <= int32 <= 1',
	  desc => 'Background color { BLACK (0), BG (1) }' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglColor *color;
      GeglNode  *node;

      if (bg_color)
        {
          color = gegl_color_duplicate (gimp_context_get_background (context));
          gimp_color_set_alpha (color, 0.0);
        }
      else
        {
          color = gegl_color_new ("black");
          gegl_color_set_rgba_with_space (color, 0.0, 0.0, 0.0, 0.0, NULL);
        }

      node = gegl_node_new_child (NULL,
                                  "operation",       "gegl:cubism",
                                  "tile-size",       tile_size,
                                  "tile-saturation", tile_saturation,
                                  "bg-color",        color,
                                  NULL);
      g_object_unref (color);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Cubism"),
                                     node);
      g_object_unref (node);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_displace {
    $blurb = 'Displace pixels as indicated by displacement maps';

    $help = <<'HELP';
Displaces the contents of the specified drawable by the amounts specified
by 'amount-x' and 'amount-y' multiplied by the luminance of corresponding
pixels in the 'displace-map' drawables.
HELP

    &std_pdb_compat('gegl:displace');
    $date = '2015';

    @inargs = (
  { name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
    desc => 'The run mode' },
  { name => 'image', type => 'image', dead => 1,
    desc => 'Input image (unused)' },
  { name => 'drawable', type => 'drawable',
    desc => 'Input drawable' },
  { name => 'amount_x', type => '-500.0 <= double <= 500.0',
    desc => 'Displace multiplier for x direction' },
  { name => 'amount_y', type => '-500.0 <= double <= 500.0',
    desc => 'Displace multiplier for y direction' },
  { name => 'do_x', type => 'boolean',
    desc => 'Displace in x direction ?' },
  { name => 'do_y', type => 'boolean',
    desc => 'Displace in y direction ?' },
  { name => 'displace_map_x', type => 'drawable',
    desc => 'Displacement map for x direction' },
  { name => 'displace_map_y', type => 'drawable',
    desc => 'Displacement map for y direction' },
  { name => 'displace_type', type => '1 <= int32 <= 3',
    desc => 'Edge behavior { WRAP (1), SMEAR (2), BLACK (3) }' }
    );

    %invoke = (
  code => <<'CODE'
{
  success = displace (drawable,
                      amount_x,
                      amount_y,
                      do_x,
                      do_y,
                      displace_map_x,
                      displace_map_y,
                      displace_type,
                      0,
                      progress,
                      error);
}
CODE
    );
}

sub plug_in_edge {
    $blurb = 'Several simple methods for detecting edges';

    $help = <<'HELP';
Perform edge detection on the contents of the specified drawable.
AMOUNT is an arbitrary constant, WRAPMODE is like displace plug-in
(useful for tileable image). EDGEMODE sets the kind of matrix transform
applied to the pixels, SOBEL was the method used in older versions.
HELP

    &std_pdb_compat('gegl:edge');
    $date = '2015';

    @inargs = (
        { name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
          desc => 'The run mode' },
        { name => 'image', type => 'image', dead => 1,
          desc => 'Input image (unused)' },
        { name => 'drawable', type => 'drawable',
          desc => 'Input drawable' },
        { name => 'amount', type => '1.0 <= double <= 10.0',
          desc => 'Edge detection amount' },
        { name => 'warpmode', type => '0 <= int32 <= 3',
          desc => 'Edge detection behavior { NONE (0), WRAP (1), SMEAR (2), BLACK (3) }' },
        { name => 'edgemode', type => '0 <= int32 <= 5',
          desc => 'Edge detection algorithm { SOBEL (0), PREWITT (1), GRADIENT (2), ROBERTS (3), DIFFERENTIAL (4), LAPLACE (5) }' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode        *node;
      GeglAbyssPolicy  border_behavior = GEGL_ABYSS_NONE;

      switch (warpmode)
        {
	case 0:
	  border_behavior = GEGL_ABYSS_NONE;
	  break;

	case 1:
	  border_behavior = GEGL_ABYSS_LOOP;
	  break;

        case 2:
	  border_behavior = GEGL_ABYSS_CLAMP;
	  break;

        case 3:
	  border_behavior = GEGL_ABYSS_BLACK;
	  break;
	}

      node = gegl_node_new_child (NULL,
                                  "operation",       "gegl:edge",
                                  "algorithm",       edgemode,
                                  "amount",          amount,
                                  "border-behavior", border_behavior,
                                  NULL);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Edge"),
                                     node);
      g_object_unref (node);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_emboss {
    $blurb = 'Simulate an image created by embossing';

    $help = <<'HELP';
Emboss or Bumpmap the given drawable, specifying the angle and
elevation for the light source.
HELP

    &std_pdb_compat('gegl:emboss');
    $date = '2019';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image', dead => 1,
	  desc => 'Input image (unused)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' },
	{ name => 'azimuth', type => '0.0 <= double <= 360.0',
	  desc => 'The Light Angle (degrees)' },
	{ name => 'elevation', type => '0.0 <= double <= 180',
	  desc => 'The Elevation Angle (degrees)' },
	{ name => 'depth', type => '0 < int32 < 100',
          default => 1, desc => 'The Filter Width' },
	{ name => 'emboss', type => 'boolean',
	  desc => 'Emboss (TRUE), Bumpmap (FALSE)' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *node;

      node = gegl_node_new_child (NULL,
                                  "operation",  "gegl:emboss",
                                  "type",       emboss ? 0 : 1,
                                  "azimuth",    azimuth,
                                  "elevation",  elevation,
                                  "depth",      depth,
                                  NULL);

      node = wrap_in_gamma_cast (node, drawable);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Emboss"),
                                     node);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_gauss {
    $blurb = 'Simplest, most commonly used way of blurring';

    $help = <<'HELP';
Applies a gaussian blur to the drawable, with specified radius of affect.
The standard deviation of the normal distribution used to modify pixel
values is calculated based on the supplied radius.
Horizontal and vertical blurring can be independently invoked by specifying
only one to run. The 'method' parameter is ignored.
HELP

    &std_pdb_compat('gegl:gaussian-blur');
    $date = '2014';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image', dead => 1,
	  desc => 'Input image (unused)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' },
	{ name => 'horizontal', type => '0.0 <= double <= 1500.0',
	  desc => 'Horizontal radius of gaussian blur (in pixels)' },
	{ name => 'vertical', type => '0.0 <= double <= 1500.0',
	  desc => 'Vertical radius of gaussian blur (in pixels)' },
	{ name => 'method', type => '0 <= int32 <= 1',
	  desc => 'Blur method { AUTO (0), FIR (1), IIR (2) }' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gaussian_blur (drawable, horizontal, vertical, method, progress,
                           error);
}
CODE
    );
}

sub plug_in_maze {
    $blurb = 'Draw a labyrinth';

    $help = <<'HELP';
Generates a maze using either the depth-first search method or Prim's
algorithm.  Can make tileable mazes too.
HELP

    &std_pdb_compat('gegl:maze');
    $date = '2015';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image', dead => 1,
	  desc => 'Input image (unused)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' },
	{ name => 'width', type => '1 <= int32 <= 1024',
	  desc => 'Width of the passages' },
	{ name => 'height', type => '1 <= int32 <= 1024',
	  desc => 'Height of the passages' },
	{ name => 'tileable', type => 'boolean',
	  desc => 'Tileable maze?' },
	{ name => 'algorithm', type => '0 <= int32 <= 1',
	  desc => 'Generation algorithm (0 = DEPTH FIRST, 1 = PRIM\'S ALGORITHM)' },
	{ name => 'seed', type => 'int32',
	  desc => 'Random Seed' },
	{ name => 'multiple', type => 'int32', dead => 1,
	  desc => 'Multiple (use 57)' },
	{ name => 'offset', type => 'int32', dead => 1,
	  desc => 'Offset (use 1)' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode  *node;
      GeglColor *fg_color;
      GeglColor *bg_color;

      fg_color = gimp_context_get_foreground (context);
      bg_color = gimp_context_get_background (context);

      node =  gegl_node_new_child (NULL,
                                   "operation",      "gegl:maze",
                                   "x",              width,
                                   "y",              height,
                                   "algorithm-type", algorithm,
                                   "tileable",       tileable,
                                   "seed",           seed,
                                   "fg-color",       fg_color,
                                   "bg-color",       bg_color,
                                   NULL);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Maze"),
                                    node);
      g_object_unref (node);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_oilify {
    $blurb = 'Smear colors to simulate an oil painting';

    $help = <<'HELP';
This function performs the well-known oil-paint effect on the
specified drawable.
HELP

    &std_pdb_compat('gegl:oilify');
    $date = '2019';

    @inargs = (
        { name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
          desc => 'The run mode' },
        { name => 'image', type => 'image', dead => 1,
          desc => 'Input image (unused)' },
        { name => 'drawable', type => 'drawable',
          desc => 'Input drawable' },
        { name => 'mask_size', type => '1 <= int32 <= 200',
          desc => 'Oil paint mask size' },
        { name => 'mode', type => '0 <= int32 <= 1',
          desc => 'Algorithm { RGB (0), INTENSITY (1) }' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *node;

      node = gegl_node_new_child (NULL,
                                  "operation",       "gegl:oilify",
                                  "mask-radius",     MAX (1, mask_size / 2),
                                  "use-inten",       mode ? TRUE : FALSE,
                                  NULL);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Oilify"),
                                     node);
      g_object_unref (node);
    }
  else
    success = FALSE;
}
CODE
    );
}

# We simplify the GEGL signature, reducing tile width and height to just size

sub plug_in_plasma {
    $blurb = 'Create a random plasma texture';

    $help = <<'HELP';
This plug-in produces plasma fractal images.
HELP

    &std_pdb_compat('gegl:plasma');
    $date = '2013';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image', dead => 1,
	  desc => 'Input image (unused)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' },
	{ name => 'seed', type => '-1 <= int32 <= G_MAXINT',
	  desc => 'Random seed' },
	{ name => 'turbulence', type => '0.0 <= double <= 7.0',
	  desc => 'The value of the turbulence' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GimpImage *image = gimp_item_get_image (GIMP_ITEM (drawable));
      GeglNode  *node;
      gint       x, y, width, height;

      gimp_item_mask_intersect (GIMP_ITEM (drawable), &x, &y, &width, &height);

      if (! gimp_channel_is_empty (gimp_image_get_mask (image)))
        x = y = 0;

      node = gegl_node_new_child (NULL,
                                  "operation",  "gegl:plasma",
                                  "seed",       seed,
                                  "turbulence", turbulence,
                                  "x",          x,
                                  "y",          y,
                                  "width",      width,
                                  "height",     height,
                                  NULL);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Plasma"),
                                     node);
      g_object_unref (node);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_rotate {
    $blurb = 'Rotates a layer or the whole image by 90, 180 or 270 degrees';

    $help = <<'HELP';
This plug-in does rotate the active layer or the whole image clockwise
by multiples of 90 degrees.  When the whole image is chosen, the image
is resized if necessary.
HELP

    &neo_pdb_misc;
    $date = '2014';

    @inargs = (
        { name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
          desc => 'The run mode' },
        { name => 'image', type => 'image',
          desc => 'Input image (unused)' },
        { name => 'drawable', type => 'drawable',
          desc => 'Input drawable' },
        { name => 'angle', type => '1 <= int32 <= 3',
          desc => 'Angle { 90 (1), 180 (2), 270 (3) } degrees' },
        { name => 'everything', type => 'boolean',
          desc => 'Rotate the whole image' }
    );

    %invoke = (
        code => <<'CODE'
{
  GimpRotationType rotate_type = angle - 1;

  if (everything)
    {
      gimp_image_rotate (image, context, rotate_type, progress);
    }
  else if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                      GIMP_PDB_ITEM_CONTENT, error))
    {
      GimpItem *item = GIMP_ITEM (drawable);
      gint      off_x, off_y;
      gdouble   center_x, center_y;

      gimp_item_get_offset (item, &off_x, &off_y);

      center_x = ((gdouble) off_x + (gdouble) gimp_item_get_width  (item) / 2.0);
      center_y = ((gdouble) off_y + (gdouble) gimp_item_get_height (item) / 2.0);

      gimp_item_rotate (item, context, rotate_type, center_x, center_y,
                        GIMP_IS_CHANNEL (drawable));
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_noisify {
    $blurb = 'Adds random noise to image channels';

    $help = <<'HELP';
Add normally distributed random values to image channels. For color
images each color channel may be treated together or independently.
HELP

    &std_pdb_compat('gegl:noise-rgb');
    $date = '2013';

    @inargs = (
        { name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
          desc => 'The run mode' },
        { name => 'image', type => 'image', dead => 1,
          desc => 'Input image (unused)' },
        { name => 'drawable', type => 'drawable',
          desc => 'Input drawable' },
        { name => 'independent', type => 'boolean',
          desc => 'Noise in channels independent' },
        { name => 'noise_1', type => '0.0 <= double <= 1.0',
          desc => 'Noise in the first channel (red, gray)' },
        { name => 'noise_2', type => '0.0 <= double <= 1.0',
          desc => 'Noise in the second channel (green, gray_alpha)' },
        { name => 'noise_3', type => '0.0 <= double <= 1.0',
          desc => 'Noise in the third channel (blue)' },
        { name => 'noise_4', type => '0.0 <= double <= 1.0',
          desc => 'Noise in the fourth channel (alpha)' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *node;
      gdouble   r, g, b, a;

      if (gimp_drawable_is_gray (drawable))
        {
          r = noise_1;
          g = noise_1;
          b = noise_1;
          a = noise_2;
        }
      else
        {
          r = noise_1;
          g = noise_2;
          b = noise_3;
          a = noise_4;
        }

      node = gegl_node_new_child (NULL,
                                  "operation",   "gegl:noise-rgb",
                                  "correlated",  FALSE,
                                  "independent", independent,
                                  "red",         r,
                                  "green",       g,
                                  "blue",        b,
                                  "alpha",       a,
                                  "seed",        g_random_int (),
                                  NULL);

      node = wrap_in_gamma_cast (node, drawable);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Noisify"),
                                     node);
      g_object_unref (node);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_solid_noise {
    $blurb = 'Create a random cloud-like texture';

    $help = <<'HELP';
Generates 2D textures using Perlin's classic solid noise function.
HELP

    &std_pdb_compat('gegl:noise-solid');
    $date = '2014';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image', dead => 1,
	  desc => 'Input image (unused)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' },
        { name => 'tileable', type => 'boolean',
          desc => 'Create a tileable output' },
        { name => 'turbulent', type => 'boolean',
          desc => 'Make a turbulent noise' },
        { name => 'seed', type => 'int32',
          desc => 'Random seed' },
        { name => 'detail', type => '0 <= int32 <= 15',
          desc => 'Detail level' },
        { name => 'xsize', type => '0.1 <= double <= 16.0',
          desc => 'Horizontal texture size' },
        { name => 'ysize', type => '0.1 <= double <= 16.0',
          desc => 'Vertical texture size' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *node;
      gint      x, y, width, height;

      gimp_item_mask_intersect (GIMP_ITEM (drawable), &x, &y, &width, &height);

      node = gegl_node_new_child (NULL,
                                  "operation", "gegl:noise-solid",
                                  "x-size",    xsize,
                                  "y-size",    ysize,
                                  "detail",    detail,
                                  "tileable",  tileable,
                                  "turbulent", turbulent,
                                  "seed",      seed,
                                  "width",     width,
                                  "height",    height,
                                  NULL);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Solid Noise"),
                                     node);
      g_object_unref (node);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_spread {
    $blurb = 'Move pixels around randomly';

    $help = <<'HELP';
Spreads the pixels of the specified drawable.  Pixels are randomly
moved to another location whose distance varies from the original by
the horizontal and vertical spread amounts.
HELP

    &std_pdb_compat('gegl:noise-spread');
    $date = '2013';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image', dead => 1,
	  desc => 'Input image (unused)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' },
	{ name => 'spread_amount_x', type => '0 <= double <= 512',
	  desc => 'Horizontal spread amount' },
	{ name => 'spread_amount_y', type => '0 <= double <= 512',
	  desc => 'Vertical spread amount' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *node =
        gegl_node_new_child (NULL,
                             "operation", "gegl:noise-spread",
                             "amount-x",  (gint) spread_amount_x,
                             "amount-y",  (gint) spread_amount_y,
                             "seed",      g_random_int (),
                             NULL);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Spread"),
                                     node);
      g_object_unref (node);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_threshold_alpha {
    $blurb = 'Make transparency all-or-nothing';

    $help = <<'HELP';
Make transparency all-or-nothing.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image', dead => 1,
	  desc => 'Input image (unused)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' },
	{ name => 'threshold', type => '0 <= int32 <= 255',
	  desc => 'Threshold' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error) &&
      gimp_drawable_has_alpha (drawable))
    {
      GeglNode *node =
        gegl_node_new_child (NULL,
                             "operation", "gimp:threshold-alpha",
                             "value",     threshold / 255.0,
                             NULL);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Threshold Alpha"),
                                     node);
      g_object_unref (node);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_waves {
    $blurb = 'Distort the image with waves';

    $help = <<'HELP';
Distort the image with waves.
HELP

    &std_pdb_compat('gegl:waves');
    $date = '2013';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image', dead => 1,
	  desc => 'Input image (unused)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' },
	{ name => 'amplitude', type => '0 <= double <= 101',
	  desc => 'The Amplitude of the Waves' },
	{ name => 'phase', type => '-360 <= double <= 360',
	  desc => 'The Phase of the Waves' },
	{ name => 'wavelength', type => '0.1 <= double <= 100',
	  desc => 'The Wavelength of the Waves' },
	{ name => 'type', type => 'boolean',
	  desc => 'Type of waves: { 0 = smeared, 1 = black }' },
	{ name => 'reflective', type => 'boolean', dead => 1,
	  desc => 'Use Reflection (not implemented)' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *node;
      gdouble   width  = gimp_item_get_width  (GIMP_ITEM (drawable));
      gdouble   height = gimp_item_get_height (GIMP_ITEM (drawable));
      gdouble   aspect;

      while (phase < 0)
        phase += 360.0;

      phase = fmod (phase, 360.0);

      aspect = CLAMP (width / height, 0.1, 10.0);

      node = gegl_node_new_child (NULL,
                                 "operation", "gegl:waves",
                                 "x",         0.5,
                                 "y",         0.5,
                                 "amplitude", amplitude,
                                 "phi",       (phase - 180.0) / 180.0,
                                 "period",    wavelength * 2.0,
                                 "aspect",    aspect,
                                 "clamp",     ! type,
                                 NULL);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Waves"),
                                     node);
      g_object_unref (node);
    }
  else
    success = FALSE;
}
CODE
    );
}

$extra{app}->{code} = <<'CODE';
static GeglNode *
wrap_in_graph (GeglNode *node)
{
  GeglNode *new_node;
  GeglNode *input;
  GeglNode *output;

  new_node = gegl_node_new ();

  gegl_node_add_child (new_node, node);
  g_object_unref (node);

  gimp_gegl_node_set_underlying_operation (new_node, node);

  input  = gegl_node_get_input_proxy  (new_node, "input");
  output = gegl_node_get_output_proxy (new_node, "output");

  gegl_node_link_many (input,
                       node,
                       output,
                       NULL);

  return new_node;
}

static GeglNode *
wrap_in_selection_bounds (GeglNode     *node,
                          GimpDrawable *drawable)
{
  gint x, y;
  gint width, height;

  if (gimp_item_mask_intersect (GIMP_ITEM (drawable),
                                &x, &y, &width, &height))
    {
      GeglNode *new_node;
      GeglNode *input;
      GeglNode *output;
      GeglNode *translate_before;
      GeglNode *crop;
      GeglNode *translate_after;

      new_node = gegl_node_new ();

      gegl_node_add_child (new_node, node);
      g_object_unref (node);

      gimp_gegl_node_set_underlying_operation (new_node, node);

      input  = gegl_node_get_input_proxy  (new_node, "input");
      output = gegl_node_get_output_proxy (new_node, "output");

      translate_before = gegl_node_new_child (new_node,
                                              "operation", "gegl:translate",
                                              "x",         (gdouble) -x,
                                              "y",         (gdouble) -y,
                                              NULL);
      crop = gegl_node_new_child (new_node,
                                  "operation", "gegl:crop",
                                  "width",     (gdouble) width,
                                  "height",    (gdouble) height,
                                  NULL);
      translate_after = gegl_node_new_child (new_node,
                                             "operation", "gegl:translate",
                                             "x",         (gdouble) x,
                                             "y",         (gdouble) y,
                                             NULL);

      gegl_node_link_many (input,
                           translate_before,
                           crop,
                           node,
                           translate_after,
                           output,
                           NULL);

      return new_node;
    }
  else
    {
      return node;
    }
}

static GeglNode *
wrap_in_gamma_cast (GeglNode     *node,
                    GimpDrawable *drawable)
{
  if (gimp_drawable_get_trc (drawable) != GIMP_TRC_LINEAR)
    {
      const Babl *drawable_format;
      const Babl *cast_format;
      GeglNode   *new_node;
      GeglNode   *input;
      GeglNode   *output;
      GeglNode   *cast_before;
      GeglNode   *cast_after;

      drawable_format = gimp_drawable_get_format (drawable);

      cast_format =
        gimp_babl_format (gimp_babl_format_get_base_type (drawable_format),
                          gimp_babl_precision (gimp_babl_format_get_component_type (drawable_format),
                                               GIMP_TRC_LINEAR),
                          babl_format_has_alpha (drawable_format),
                          babl_format_get_space (drawable_format));

      new_node = gegl_node_new ();

      gegl_node_add_child (new_node, node);
      g_object_unref (node);

      gimp_gegl_node_set_underlying_operation (new_node, node);

      input  = gegl_node_get_input_proxy  (new_node, "input");
      output = gegl_node_get_output_proxy (new_node, "output");

      cast_before = gegl_node_new_child (new_node,
                                         "operation",     "gegl:cast-format",
                                         "input-format",  drawable_format,
                                         "output-format", cast_format,
                                         NULL);
      cast_after  = gegl_node_new_child (new_node,
                                         "operation",     "gegl:cast-format",
                                         "input-format",  cast_format,
                                         "output-format", drawable_format,
                                         NULL);

      gegl_node_link_many (input,
                           cast_before,
                           node,
                           cast_after,
                           output,
                           NULL);

      return new_node;
    }
  else
    {
      return node;
    }
}

static GeglNode *
create_buffer_source_node (GeglNode     *parent,
                           GimpDrawable *drawable)
{
  GeglNode   *new_node;
  GeglBuffer *buffer;

  buffer = gimp_drawable_get_buffer (drawable);
  g_object_ref (buffer);
  new_node = gegl_node_new_child (parent,
                                  "operation", "gegl:buffer-source",
                                  "buffer", buffer,
                                  NULL);
  g_object_unref (buffer);
  return new_node;
}

static gboolean
bump_map (GimpDrawable *drawable,
          GimpDrawable *bump_map,
          gdouble       azimuth,
          gdouble       elevation,
          gint          depth,
          gint          offset_x,
          gint          offset_y,
          gdouble       waterlevel,
          gdouble       ambient,
          gboolean      compensate,
          gboolean      invert,
          gint          type,
          gboolean      tiled,
          GimpProgress  *progress,
          GError       **error)
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *graph;
      GeglNode *node;
      GeglNode *src_node;

      node = gegl_node_new_child (NULL,
                                  "operation", "gegl:bump-map",
                                  "tiled",      tiled,
                                  "type",       type,
                                  "compensate", compensate,
                                  "invert",     invert,
                                  "azimuth",    azimuth,
                                  "elevation",  elevation,
                                  "depth",      depth,
                                  "offset_x",   offset_x,
                                  "offset_y",   offset_y,
                                  "waterlevel", waterlevel,
                                  "ambient",    ambient,
                                  NULL);

      graph = wrap_in_graph (node);

      src_node = create_buffer_source_node (graph, bump_map);

      gegl_node_connect (src_node, "output", node, "aux");

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Bump Map"),
                                     graph);
      g_object_unref (graph);

      return TRUE;
    }
    else
      return FALSE;
}

static gboolean
displace (GimpDrawable  *drawable,
          gdouble        amount_x,
          gdouble        amount_y,
          gboolean       do_x,
          gboolean       do_y,
          GimpDrawable  *displace_map_x,
          GimpDrawable  *displace_map_y,
          gint           displace_type,
          gint           displace_mode,
          GimpProgress  *progress,
          GError       **error)
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      if (do_x || do_y)
        {
          GeglNode *graph;
          GeglNode *node;
          GeglAbyssPolicy abyss_policy = GEGL_ABYSS_NONE;

          switch (displace_type)
            {
              case 1:
                abyss_policy = GEGL_ABYSS_LOOP;
                break;
              case 2:
                abyss_policy = GEGL_ABYSS_CLAMP;
                break;
              case 3:
                abyss_policy = GEGL_ABYSS_BLACK;
                break;
            }

          node = gegl_node_new_child (NULL,
                                      "operation",     "gegl:displace",
                                      "displace_mode", displace_mode,
                                      "sampler_type",  GEGL_SAMPLER_CUBIC,
                                      "abyss_policy",  abyss_policy,
                                      "amount_x",      amount_x,
                                      "amount_y",      amount_y,
                                      NULL);

          graph = wrap_in_graph (node);

          if (do_x)
            {
              GeglNode *src_node;
              src_node = create_buffer_source_node (graph, displace_map_x);
              gegl_node_connect (src_node, "output", node, "aux");
            }

          if (do_y)
            {
              GeglNode *src_node;
              src_node = create_buffer_source_node (graph, displace_map_y);
              gegl_node_connect (src_node, "output", node, "aux2");
            }

          gimp_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Displace"),
                                         graph);
          g_object_unref (graph);
        }

      return TRUE;
    }
  else
    return FALSE;
}

static gboolean
gaussian_blur (GimpDrawable  *drawable,
               gdouble        horizontal,
               gdouble        vertical,
               gint           method,
               GimpProgress  *progress,
               GError       **error)
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *node;

      node = gegl_node_new_child (NULL,
                                  "operation",    "gegl:gaussian-blur",
                                  "std-dev-x",    horizontal,
                                  "std-dev-y",    vertical,
                                  "filter",       method,
                                  "abyss-policy", 1,
                                  NULL);

      node = wrap_in_gamma_cast (node, drawable);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Gaussian Blur"),
                                     node);
      g_object_unref (node);

      return TRUE;
    }

  return FALSE;
}

static gint
newsprint_color_model (gint colorspace)
{
  switch (colorspace)
    {
    case 0: return 1; /* black on white */
    case 1: return 2; /* rgb */
    case 2: return 3; /* cmyk */
    case 3: return 1; /* black on white */
    }

  return 2;
}

static gint
newsprint_pattern (gint spotfn)
{
  switch (spotfn)
    {
    case 0: return 1; /* circle */
    case 1: return 0; /* line */
    case 2: return 2; /* diamond */
    case 3: return 4; /* ps circle */
    case 4: return 2; /* FIXME postscript diamond */
    }

  return 1;
}

static gdouble
newsprint_angle (gdouble angle)
{
  while (angle > 180.0)
    angle -= 360.0;

  while (angle < -180.0)
    angle += 360.0;

  return angle;
}
CODE

@headers = qw(<cairo.h>
              "libgimpbase/gimpbase.h"
              "libgimpcolor/gimpcolor.h"
              "libgimpconfig/gimpconfig.h"
              "libgimpmath/gimpmath.h"
              "gegl/gimp-babl.h"
              "gegl/gimp-gegl-utils.h"
              "config/gimpcoreconfig.h"
              "core/gimp.h"
              "core/gimpchannel.h"
              "core/gimpcontext.h"
              "core/gimpdrawable-operation.h"
              "core/gimpimage-crop.h"
              "core/gimpimage-resize.h"
              "core/gimpimage-rotate.h"
              "core/gimpimage-undo.h"
              "core/gimppickable.h"
              "core/gimppickable-auto-shrink.h"
              "gimppdberror.h"
              "gimppdb-utils.h"
              "gimp-intl.h");

@procs = qw(plug_in_autocrop
            plug_in_autocrop_layer
            plug_in_bump_map
            plug_in_cubism
            plug_in_displace
            plug_in_edge
            plug_in_emboss
            plug_in_gauss
            plug_in_maze
            plug_in_oilify
            plug_in_plasma
            plug_in_rotate
            plug_in_noisify
            plug_in_solid_noise
            plug_in_spread
            plug_in_threshold_alpha
            plug_in_waves);

%exports = (app => [@procs], lib => []);

$desc = 'Plug-in Compat';
$doc_title = 'gimpplugincompat';
$doc_short_desc = 'Compatibility for removed plug-ins.';
$doc_long_desc = 'Functions that perform the operation of removed plug-ins using GEGL operations or other GIMP internal functions.';

1;
