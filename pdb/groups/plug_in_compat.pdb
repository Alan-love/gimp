# GIMP - The GNU Image Manipulation Program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>


# The declared ranges generate min/max in GParamSpecs
# and the min becomes the default in the GParamSpecs.
# A declared range must correspond with range declared in GEGL
# else args defaulted from min may generate out-of-range warnings.

sub plug_in_autocrop {
    $blurb = 'Remove empty borders from the image';

    $help = <<'HELP';
Remove empty borders from the image.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image',
	  desc => 'Input image)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error))
    {
      gint x, y, width, height;
      gint off_x, off_y;

      gimp_pickable_auto_shrink (GIMP_PICKABLE (drawable),
                                 0, 0,
                                 gimp_item_get_width  (GIMP_ITEM (drawable)),
                                 gimp_item_get_height (GIMP_ITEM (drawable)),
                                 &x, &y, &width, &height);

      gimp_item_get_offset (GIMP_ITEM (drawable), &off_x, &off_y);
      x += off_x;
      y += off_y;

      gimp_image_undo_group_start (image, GIMP_UNDO_GROUP_ITEM_RESIZE,
                                   _("Autocrop image"));

      if (x          < 0                             ||
          y          < 0                             ||
          x + width  > gimp_image_get_width  (image) ||
          y + height > gimp_image_get_height (image))
        {
          /*
           * partially outside the image area, we need to
           * resize the image to be able to crop properly.
           */
          gimp_image_resize (image, context, width, height, -x, -y, NULL);

          x = y = 0;
        }

      gimp_image_crop (image, context, GIMP_FILL_TRANSPARENT,
                       x, y, width, height, TRUE);

      gimp_image_undo_group_end (image);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_autocrop_layer {
    $blurb = 'Crop the selected layers based on empty borders of the input drawable';

    $help = <<'HELP';
Crop the selected layers of the input "image" based on empty borders of the input "drawable".
\n\nThe input drawable serves as a base for detecting cropping extents (transparency or background color), and is not necessarily among the cropped layers (the current selected layers).
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image',
	  desc => 'Input image)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error))
    {
      GList *layers = gimp_image_get_selected_layers (image);
      GList *iter;
      gint   x, y, width, height;

      if (layers)
        {
          switch (gimp_pickable_auto_shrink (GIMP_PICKABLE (drawable),
                                             0, 0,
                                             gimp_item_get_width  (GIMP_ITEM (drawable)),
                                             gimp_item_get_height (GIMP_ITEM (drawable)),
                                             &x, &y, &width, &height))
            {
            case GIMP_AUTO_SHRINK_SHRINK:
              gimp_image_undo_group_start (image, GIMP_UNDO_GROUP_ITEM_RESIZE,
                                           _("Autocrop layer"));

              for (iter = layers; iter; iter = iter->next)
                  gimp_item_resize (GIMP_ITEM (iter->data),
                                    context, GIMP_FILL_TRANSPARENT,
                                    width, height, -x, -y);

              gimp_image_undo_group_end (image);
	      break;

	    default:
	      break;
            }
	}
      else
        {
          success = FALSE;
        }
    }
  else
    {
      success = FALSE;
    }
}
CODE
    );
}

sub plug_in_bump_map {
    $blurb = 'Create an embossing effect using a bump map';

    $help = <<'HELP';
This plug-in uses the algorithm described by John Schlag,
"Fast Embossing Effects on Raster Image Data" in
Graphics GEMS IV (ISBN 0-12-336155-9).
It takes a drawable to be applied as a bump
map to another image and produces a nice embossing effect.
HELP

    &std_pdb_compat('gegl:bump-map');
    $date = '2015';

    @inargs = (
  { name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
    desc => 'The run mode' },
  { name => 'image', type => 'image', dead => 1,
    desc => 'Input image (unused)' },
  { name => 'drawable', type => 'drawable',
    desc => 'Input drawable' },
  { name => 'bumpmap', type => 'drawable',
    desc => 'Bump map drawable' },
  { name => 'azimuth', type => '0.0 <= double <= 360.0',
    desc => 'Azimuth' },
  { name => 'elevation', type => '0.5 <= double <= 90.0',
    desc => 'Elevation' },
  { name => 'depth', type => '1 <= int32 <= 65',
    desc => 'Depth' },
  { name => 'xofs', type => 'int32',
    desc => 'X offset' },
  { name => 'yofs', type => 'int32',
    desc => 'Y offset' },
  { name => 'waterlevel', type => '0.0 <= double <= 1.0',
    desc => 'Level that full transparency should represent' },
  { name => 'ambient', type => '0.0 <= double <= 1.0',
    desc => 'Ambient lighting factor' },
  { name => 'compensate', type => 'boolean',
    desc => 'Compensate for darkening' },
  { name => 'invert', type => 'boolean',
    desc => 'Invert bumpmap' },
  { name => 'type', type => '0 <= int32 <= 3',
    desc => 'Type of map { LINEAR (0), SPHERICAL (1), SINUSOIDAL (2) }' }
    );

    %invoke = (
  code => <<'CODE'
{
  success = bump_map (drawable,
                      bumpmap,
                      azimuth,
                      elevation,
                      depth,
                      xofs,
                      yofs,
                      waterlevel,
                      ambient,
                      compensate,
                      invert,
                      type,
                      FALSE,
                      progress,
                      error);
}
CODE
    );
}

# We simplify the GEGL signature, reducing tile width and height to just size

$extra{app}->{code} = <<'CODE';
static GeglNode *
wrap_in_graph (GeglNode *node)
{
  GeglNode *new_node;
  GeglNode *input;
  GeglNode *output;

  new_node = gegl_node_new ();

  gegl_node_add_child (new_node, node);
  g_object_unref (node);

  gimp_gegl_node_set_underlying_operation (new_node, node);

  input  = gegl_node_get_input_proxy  (new_node, "input");
  output = gegl_node_get_output_proxy (new_node, "output");

  gegl_node_link_many (input,
                       node,
                       output,
                       NULL);

  return new_node;
}

static GeglNode *
wrap_in_selection_bounds (GeglNode     *node,
                          GimpDrawable *drawable)
{
  gint x, y;
  gint width, height;

  if (gimp_item_mask_intersect (GIMP_ITEM (drawable),
                                &x, &y, &width, &height))
    {
      GeglNode *new_node;
      GeglNode *input;
      GeglNode *output;
      GeglNode *translate_before;
      GeglNode *crop;
      GeglNode *translate_after;

      new_node = gegl_node_new ();

      gegl_node_add_child (new_node, node);
      g_object_unref (node);

      gimp_gegl_node_set_underlying_operation (new_node, node);

      input  = gegl_node_get_input_proxy  (new_node, "input");
      output = gegl_node_get_output_proxy (new_node, "output");

      translate_before = gegl_node_new_child (new_node,
                                              "operation", "gegl:translate",
                                              "x",         (gdouble) -x,
                                              "y",         (gdouble) -y,
                                              NULL);
      crop = gegl_node_new_child (new_node,
                                  "operation", "gegl:crop",
                                  "width",     (gdouble) width,
                                  "height",    (gdouble) height,
                                  NULL);
      translate_after = gegl_node_new_child (new_node,
                                             "operation", "gegl:translate",
                                             "x",         (gdouble) x,
                                             "y",         (gdouble) y,
                                             NULL);

      gegl_node_link_many (input,
                           translate_before,
                           crop,
                           node,
                           translate_after,
                           output,
                           NULL);

      return new_node;
    }
  else
    {
      return node;
    }
}

static GeglNode *
create_buffer_source_node (GeglNode     *parent,
                           GimpDrawable *drawable)
{
  GeglNode   *new_node;
  GeglBuffer *buffer;

  buffer = gimp_drawable_get_buffer (drawable);
  g_object_ref (buffer);
  new_node = gegl_node_new_child (parent,
                                  "operation", "gegl:buffer-source",
                                  "buffer", buffer,
                                  NULL);
  g_object_unref (buffer);
  return new_node;
}

static gboolean
bump_map (GimpDrawable *drawable,
          GimpDrawable *bump_map,
          gdouble       azimuth,
          gdouble       elevation,
          gint          depth,
          gint          offset_x,
          gint          offset_y,
          gdouble       waterlevel,
          gdouble       ambient,
          gboolean      compensate,
          gboolean      invert,
          gint          type,
          gboolean      tiled,
          GimpProgress  *progress,
          GError       **error)
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *graph;
      GeglNode *node;
      GeglNode *src_node;

      node = gegl_node_new_child (NULL,
                                  "operation", "gegl:bump-map",
                                  "tiled",      tiled,
                                  "type",       type,
                                  "compensate", compensate,
                                  "invert",     invert,
                                  "azimuth",    azimuth,
                                  "elevation",  elevation,
                                  "depth",      depth,
                                  "offset_x",   offset_x,
                                  "offset_y",   offset_y,
                                  "waterlevel", waterlevel,
                                  "ambient",    ambient,
                                  NULL);

      graph = wrap_in_graph (node);

      src_node = create_buffer_source_node (graph, bump_map);

      gegl_node_connect (src_node, "output", node, "aux");

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Bump Map"),
                                     graph);
      g_object_unref (graph);

      return TRUE;
    }
    else
      return FALSE;
}

static gint
newsprint_color_model (gint colorspace)
{
  switch (colorspace)
    {
    case 0: return 1; /* black on white */
    case 1: return 2; /* rgb */
    case 2: return 3; /* cmyk */
    case 3: return 1; /* black on white */
    }

  return 2;
}

static gint
newsprint_pattern (gint spotfn)
{
  switch (spotfn)
    {
    case 0: return 1; /* circle */
    case 1: return 0; /* line */
    case 2: return 2; /* diamond */
    case 3: return 4; /* ps circle */
    case 4: return 2; /* FIXME postscript diamond */
    }

  return 1;
}

static gdouble
newsprint_angle (gdouble angle)
{
  while (angle > 180.0)
    angle -= 360.0;

  while (angle < -180.0)
    angle += 360.0;

  return angle;
}
CODE

@headers = qw(<cairo.h>
              "libgimpbase/gimpbase.h"
              "libgimpcolor/gimpcolor.h"
              "libgimpconfig/gimpconfig.h"
              "libgimpmath/gimpmath.h"
              "gegl/gimp-babl.h"
              "gegl/gimp-gegl-utils.h"
              "config/gimpcoreconfig.h"
              "core/gimp.h"
              "core/gimpchannel.h"
              "core/gimpcontext.h"
              "core/gimpdrawable-operation.h"
              "core/gimpimage-crop.h"
              "core/gimpimage-resize.h"
              "core/gimpimage-rotate.h"
              "core/gimpimage-undo.h"
              "core/gimppickable.h"
              "core/gimppickable-auto-shrink.h"
              "gimppdberror.h"
              "gimppdb-utils.h"
              "gimp-intl.h");

@procs = qw(plug_in_autocrop
            plug_in_autocrop_layer
            plug_in_bump_map);

%exports = (app => [@procs], lib => []);

$desc = 'Plug-in Compat';
$doc_title = 'gimpplugincompat';
$doc_short_desc = 'Compatibility for removed plug-ins.';
$doc_long_desc = 'Functions that perform the operation of removed plug-ins using GEGL operations or other GIMP internal functions.';

1;
