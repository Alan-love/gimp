# GIMP - The GNU Image Manipulation Program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# "Perlized" from C source by Manish Singh <yosh@gimp.org>


# The declared ranges generate min/max in GParamSpecs
# and the min becomes the default in the GParamSpecs.
# A declared range must correspond with range declared in GEGL
# else args defaulted from min may generate out-of-range warnings.

sub plug_in_autocrop {
    $blurb = 'Remove empty borders from the image';

    $help = <<'HELP';
Remove empty borders from the image.
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image',
	  desc => 'Input image)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error))
    {
      gint x, y, width, height;
      gint off_x, off_y;

      gimp_pickable_auto_shrink (GIMP_PICKABLE (drawable),
                                 0, 0,
                                 gimp_item_get_width  (GIMP_ITEM (drawable)),
                                 gimp_item_get_height (GIMP_ITEM (drawable)),
                                 &x, &y, &width, &height);

      gimp_item_get_offset (GIMP_ITEM (drawable), &off_x, &off_y);
      x += off_x;
      y += off_y;

      gimp_image_undo_group_start (image, GIMP_UNDO_GROUP_ITEM_RESIZE,
                                   _("Autocrop image"));

      if (x          < 0                             ||
          y          < 0                             ||
          x + width  > gimp_image_get_width  (image) ||
          y + height > gimp_image_get_height (image))
        {
          /*
           * partially outside the image area, we need to
           * resize the image to be able to crop properly.
           */
          gimp_image_resize (image, context, width, height, -x, -y, NULL);

          x = y = 0;
        }

      gimp_image_crop (image, context, GIMP_FILL_TRANSPARENT,
                       x, y, width, height, TRUE);

      gimp_image_undo_group_end (image);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_autocrop_layer {
    $blurb = 'Crop the selected layers based on empty borders of the input drawable';

    $help = <<'HELP';
Crop the selected layers of the input "image" based on empty borders of the input "drawable".
\n\nThe input drawable serves as a base for detecting cropping extents (transparency or background color), and is not necessarily among the cropped layers (the current selected layers).
HELP

    &std_pdb_misc;
    $date = '1997';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image',
	  desc => 'Input image)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error))
    {
      GList *layers = gimp_image_get_selected_layers (image);
      GList *iter;
      gint   x, y, width, height;

      if (layers)
        {
          switch (gimp_pickable_auto_shrink (GIMP_PICKABLE (drawable),
                                             0, 0,
                                             gimp_item_get_width  (GIMP_ITEM (drawable)),
                                             gimp_item_get_height (GIMP_ITEM (drawable)),
                                             &x, &y, &width, &height))
            {
            case GIMP_AUTO_SHRINK_SHRINK:
              gimp_image_undo_group_start (image, GIMP_UNDO_GROUP_ITEM_RESIZE,
                                           _("Autocrop layer"));

              for (iter = layers; iter; iter = iter->next)
                  gimp_item_resize (GIMP_ITEM (iter->data),
                                    context, GIMP_FILL_TRANSPARENT,
                                    width, height, -x, -y);

              gimp_image_undo_group_end (image);
	      break;

	    default:
	      break;
            }
	}
      else
        {
          success = FALSE;
        }
    }
  else
    {
      success = FALSE;
    }
}
CODE
    );
}

sub plug_in_bump_map {
    $blurb = 'Create an embossing effect using a bump map';

    $help = <<'HELP';
This plug-in uses the algorithm described by John Schlag,
"Fast Embossing Effects on Raster Image Data" in
Graphics GEMS IV (ISBN 0-12-336155-9).
It takes a drawable to be applied as a bump
map to another image and produces a nice embossing effect.
HELP

    &std_pdb_compat('gegl:bump-map');
    $date = '2015';

    @inargs = (
  { name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
    desc => 'The run mode' },
  { name => 'image', type => 'image', dead => 1,
    desc => 'Input image (unused)' },
  { name => 'drawable', type => 'drawable',
    desc => 'Input drawable' },
  { name => 'bumpmap', type => 'drawable',
    desc => 'Bump map drawable' },
  { name => 'azimuth', type => '0.0 <= double <= 360.0',
    desc => 'Azimuth' },
  { name => 'elevation', type => '0.5 <= double <= 90.0',
    desc => 'Elevation' },
  { name => 'depth', type => '1 <= int32 <= 65',
    desc => 'Depth' },
  { name => 'xofs', type => 'int32',
    desc => 'X offset' },
  { name => 'yofs', type => 'int32',
    desc => 'Y offset' },
  { name => 'waterlevel', type => '0.0 <= double <= 1.0',
    desc => 'Level that full transparency should represent' },
  { name => 'ambient', type => '0.0 <= double <= 1.0',
    desc => 'Ambient lighting factor' },
  { name => 'compensate', type => 'boolean',
    desc => 'Compensate for darkening' },
  { name => 'invert', type => 'boolean',
    desc => 'Invert bumpmap' },
  { name => 'type', type => '0 <= int32 <= 3',
    desc => 'Type of map { LINEAR (0), SPHERICAL (1), SINUSOIDAL (2) }' }
    );

    %invoke = (
  code => <<'CODE'
{
  success = bump_map (drawable,
                      bumpmap,
                      azimuth,
                      elevation,
                      depth,
                      xofs,
                      yofs,
                      waterlevel,
                      ambient,
                      compensate,
                      invert,
                      type,
                      FALSE,
                      progress,
                      error);
}
CODE
    );
}

sub plug_in_displace {
    $blurb = 'Displace pixels as indicated by displacement maps';

    $help = <<'HELP';
Displaces the contents of the specified drawable by the amounts specified
by 'amount-x' and 'amount-y' multiplied by the luminance of corresponding
pixels in the 'displace-map' drawables.
HELP

    &std_pdb_compat('gegl:displace');
    $date = '2015';

    @inargs = (
  { name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
    desc => 'The run mode' },
  { name => 'image', type => 'image', dead => 1,
    desc => 'Input image (unused)' },
  { name => 'drawable', type => 'drawable',
    desc => 'Input drawable' },
  { name => 'amount_x', type => '-500.0 <= double <= 500.0',
    desc => 'Displace multiplier for x direction' },
  { name => 'amount_y', type => '-500.0 <= double <= 500.0',
    desc => 'Displace multiplier for y direction' },
  { name => 'do_x', type => 'boolean',
    desc => 'Displace in x direction ?' },
  { name => 'do_y', type => 'boolean',
    desc => 'Displace in y direction ?' },
  { name => 'displace_map_x', type => 'drawable',
    desc => 'Displacement map for x direction' },
  { name => 'displace_map_y', type => 'drawable',
    desc => 'Displacement map for y direction' },
  { name => 'displace_type', type => '1 <= int32 <= 3',
    desc => 'Edge behavior { WRAP (1), SMEAR (2), BLACK (3) }' }
    );

    %invoke = (
  code => <<'CODE'
{
  success = displace (drawable,
                      amount_x,
                      amount_y,
                      do_x,
                      do_y,
                      displace_map_x,
                      displace_map_y,
                      displace_type,
                      0,
                      progress,
                      error);
}
CODE
    );
}

sub plug_in_emboss {
    $blurb = 'Simulate an image created by embossing';

    $help = <<'HELP';
Emboss or Bumpmap the given drawable, specifying the angle and
elevation for the light source.
HELP

    &std_pdb_compat('gegl:emboss');
    $date = '2019';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image', dead => 1,
	  desc => 'Input image (unused)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' },
	{ name => 'azimuth', type => '0.0 <= double <= 360.0',
	  desc => 'The Light Angle (degrees)' },
	{ name => 'elevation', type => '0.0 <= double <= 180',
	  desc => 'The Elevation Angle (degrees)' },
	{ name => 'depth', type => '0 < int32 < 100',
          default => 1, desc => 'The Filter Width' },
	{ name => 'emboss', type => 'boolean',
	  desc => 'Emboss (TRUE), Bumpmap (FALSE)' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *node;

      node = gegl_node_new_child (NULL,
                                  "operation",  "gegl:emboss",
                                  "type",       emboss ? 0 : 1,
                                  "azimuth",    azimuth,
                                  "elevation",  elevation,
                                  "depth",      depth,
                                  NULL);

      node = wrap_in_gamma_cast (node, drawable);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Emboss"),
                                     node);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_gauss {
    $blurb = 'Simplest, most commonly used way of blurring';

    $help = <<'HELP';
Applies a gaussian blur to the drawable, with specified radius of affect.
The standard deviation of the normal distribution used to modify pixel
values is calculated based on the supplied radius.
Horizontal and vertical blurring can be independently invoked by specifying
only one to run. The 'method' parameter is ignored.
HELP

    &std_pdb_compat('gegl:gaussian-blur');
    $date = '2014';

    @inargs = (
	{ name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
	  desc => 'The run mode' },
	{ name => 'image', type => 'image', dead => 1,
	  desc => 'Input image (unused)' },
	{ name => 'drawable', type => 'drawable',
	  desc => 'Input drawable' },
	{ name => 'horizontal', type => '0.0 <= double <= 1500.0',
	  desc => 'Horizontal radius of gaussian blur (in pixels)' },
	{ name => 'vertical', type => '0.0 <= double <= 1500.0',
	  desc => 'Vertical radius of gaussian blur (in pixels)' },
	{ name => 'method', type => '0 <= int32 <= 1',
	  desc => 'Blur method { AUTO (0), FIR (1), IIR (2) }' }
    );

    %invoke = (
	code => <<'CODE'
{
  success = gaussian_blur (drawable, horizontal, vertical, method, progress,
                           error);
}
CODE
    );
}

# We simplify the GEGL signature, reducing tile width and height to just size

sub plug_in_rotate {
    $blurb = 'Rotates a layer or the whole image by 90, 180 or 270 degrees';

    $help = <<'HELP';
This plug-in does rotate the active layer or the whole image clockwise
by multiples of 90 degrees.  When the whole image is chosen, the image
is resized if necessary.
HELP

    &neo_pdb_misc;
    $date = '2014';

    @inargs = (
        { name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
          desc => 'The run mode' },
        { name => 'image', type => 'image',
          desc => 'Input image (unused)' },
        { name => 'drawable', type => 'drawable',
          desc => 'Input drawable' },
        { name => 'angle', type => '1 <= int32 <= 3',
          desc => 'Angle { 90 (1), 180 (2), 270 (3) } degrees' },
        { name => 'everything', type => 'boolean',
          desc => 'Rotate the whole image' }
    );

    %invoke = (
        code => <<'CODE'
{
  GimpRotationType rotate_type = angle - 1;

  if (everything)
    {
      gimp_image_rotate (image, context, rotate_type, progress);
    }
  else if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                      GIMP_PDB_ITEM_CONTENT, error))
    {
      GimpItem *item = GIMP_ITEM (drawable);
      gint      off_x, off_y;
      gdouble   center_x, center_y;

      gimp_item_get_offset (item, &off_x, &off_y);

      center_x = ((gdouble) off_x + (gdouble) gimp_item_get_width  (item) / 2.0);
      center_y = ((gdouble) off_y + (gdouble) gimp_item_get_height (item) / 2.0);

      gimp_item_rotate (item, context, rotate_type, center_x, center_y,
                        GIMP_IS_CHANNEL (drawable));
    }
  else
    success = FALSE;
}
CODE
    );
}

sub plug_in_noisify {
    $blurb = 'Adds random noise to image channels';

    $help = <<'HELP';
Add normally distributed random values to image channels. For color
images each color channel may be treated together or independently.
HELP

    &std_pdb_compat('gegl:noise-rgb');
    $date = '2013';

    @inargs = (
        { name => 'run_mode', type => 'enum GimpRunMode', dead => 1,
          desc => 'The run mode' },
        { name => 'image', type => 'image', dead => 1,
          desc => 'Input image (unused)' },
        { name => 'drawable', type => 'drawable',
          desc => 'Input drawable' },
        { name => 'independent', type => 'boolean',
          desc => 'Noise in channels independent' },
        { name => 'noise_1', type => '0.0 <= double <= 1.0',
          desc => 'Noise in the first channel (red, gray)' },
        { name => 'noise_2', type => '0.0 <= double <= 1.0',
          desc => 'Noise in the second channel (green, gray_alpha)' },
        { name => 'noise_3', type => '0.0 <= double <= 1.0',
          desc => 'Noise in the third channel (blue)' },
        { name => 'noise_4', type => '0.0 <= double <= 1.0',
          desc => 'Noise in the fourth channel (alpha)' }
    );

    %invoke = (
        code => <<'CODE'
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *node;
      gdouble   r, g, b, a;

      if (gimp_drawable_is_gray (drawable))
        {
          r = noise_1;
          g = noise_1;
          b = noise_1;
          a = noise_2;
        }
      else
        {
          r = noise_1;
          g = noise_2;
          b = noise_3;
          a = noise_4;
        }

      node = gegl_node_new_child (NULL,
                                  "operation",   "gegl:noise-rgb",
                                  "correlated",  FALSE,
                                  "independent", independent,
                                  "red",         r,
                                  "green",       g,
                                  "blue",        b,
                                  "alpha",       a,
                                  "seed",        g_random_int (),
                                  NULL);

      node = wrap_in_gamma_cast (node, drawable);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Noisify"),
                                     node);
      g_object_unref (node);
    }
  else
    success = FALSE;
}
CODE
    );
}

$extra{app}->{code} = <<'CODE';
static GeglNode *
wrap_in_graph (GeglNode *node)
{
  GeglNode *new_node;
  GeglNode *input;
  GeglNode *output;

  new_node = gegl_node_new ();

  gegl_node_add_child (new_node, node);
  g_object_unref (node);

  gimp_gegl_node_set_underlying_operation (new_node, node);

  input  = gegl_node_get_input_proxy  (new_node, "input");
  output = gegl_node_get_output_proxy (new_node, "output");

  gegl_node_link_many (input,
                       node,
                       output,
                       NULL);

  return new_node;
}

static GeglNode *
wrap_in_selection_bounds (GeglNode     *node,
                          GimpDrawable *drawable)
{
  gint x, y;
  gint width, height;

  if (gimp_item_mask_intersect (GIMP_ITEM (drawable),
                                &x, &y, &width, &height))
    {
      GeglNode *new_node;
      GeglNode *input;
      GeglNode *output;
      GeglNode *translate_before;
      GeglNode *crop;
      GeglNode *translate_after;

      new_node = gegl_node_new ();

      gegl_node_add_child (new_node, node);
      g_object_unref (node);

      gimp_gegl_node_set_underlying_operation (new_node, node);

      input  = gegl_node_get_input_proxy  (new_node, "input");
      output = gegl_node_get_output_proxy (new_node, "output");

      translate_before = gegl_node_new_child (new_node,
                                              "operation", "gegl:translate",
                                              "x",         (gdouble) -x,
                                              "y",         (gdouble) -y,
                                              NULL);
      crop = gegl_node_new_child (new_node,
                                  "operation", "gegl:crop",
                                  "width",     (gdouble) width,
                                  "height",    (gdouble) height,
                                  NULL);
      translate_after = gegl_node_new_child (new_node,
                                             "operation", "gegl:translate",
                                             "x",         (gdouble) x,
                                             "y",         (gdouble) y,
                                             NULL);

      gegl_node_link_many (input,
                           translate_before,
                           crop,
                           node,
                           translate_after,
                           output,
                           NULL);

      return new_node;
    }
  else
    {
      return node;
    }
}

static GeglNode *
wrap_in_gamma_cast (GeglNode     *node,
                    GimpDrawable *drawable)
{
  if (gimp_drawable_get_trc (drawable) != GIMP_TRC_LINEAR)
    {
      const Babl *drawable_format;
      const Babl *cast_format;
      GeglNode   *new_node;
      GeglNode   *input;
      GeglNode   *output;
      GeglNode   *cast_before;
      GeglNode   *cast_after;

      drawable_format = gimp_drawable_get_format (drawable);

      cast_format =
        gimp_babl_format (gimp_babl_format_get_base_type (drawable_format),
                          gimp_babl_precision (gimp_babl_format_get_component_type (drawable_format),
                                               GIMP_TRC_LINEAR),
                          babl_format_has_alpha (drawable_format),
                          babl_format_get_space (drawable_format));

      new_node = gegl_node_new ();

      gegl_node_add_child (new_node, node);
      g_object_unref (node);

      gimp_gegl_node_set_underlying_operation (new_node, node);

      input  = gegl_node_get_input_proxy  (new_node, "input");
      output = gegl_node_get_output_proxy (new_node, "output");

      cast_before = gegl_node_new_child (new_node,
                                         "operation",     "gegl:cast-format",
                                         "input-format",  drawable_format,
                                         "output-format", cast_format,
                                         NULL);
      cast_after  = gegl_node_new_child (new_node,
                                         "operation",     "gegl:cast-format",
                                         "input-format",  cast_format,
                                         "output-format", drawable_format,
                                         NULL);

      gegl_node_link_many (input,
                           cast_before,
                           node,
                           cast_after,
                           output,
                           NULL);

      return new_node;
    }
  else
    {
      return node;
    }
}

static GeglNode *
create_buffer_source_node (GeglNode     *parent,
                           GimpDrawable *drawable)
{
  GeglNode   *new_node;
  GeglBuffer *buffer;

  buffer = gimp_drawable_get_buffer (drawable);
  g_object_ref (buffer);
  new_node = gegl_node_new_child (parent,
                                  "operation", "gegl:buffer-source",
                                  "buffer", buffer,
                                  NULL);
  g_object_unref (buffer);
  return new_node;
}

static gboolean
bump_map (GimpDrawable *drawable,
          GimpDrawable *bump_map,
          gdouble       azimuth,
          gdouble       elevation,
          gint          depth,
          gint          offset_x,
          gint          offset_y,
          gdouble       waterlevel,
          gdouble       ambient,
          gboolean      compensate,
          gboolean      invert,
          gint          type,
          gboolean      tiled,
          GimpProgress  *progress,
          GError       **error)
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *graph;
      GeglNode *node;
      GeglNode *src_node;

      node = gegl_node_new_child (NULL,
                                  "operation", "gegl:bump-map",
                                  "tiled",      tiled,
                                  "type",       type,
                                  "compensate", compensate,
                                  "invert",     invert,
                                  "azimuth",    azimuth,
                                  "elevation",  elevation,
                                  "depth",      depth,
                                  "offset_x",   offset_x,
                                  "offset_y",   offset_y,
                                  "waterlevel", waterlevel,
                                  "ambient",    ambient,
                                  NULL);

      graph = wrap_in_graph (node);

      src_node = create_buffer_source_node (graph, bump_map);

      gegl_node_connect (src_node, "output", node, "aux");

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Bump Map"),
                                     graph);
      g_object_unref (graph);

      return TRUE;
    }
    else
      return FALSE;
}

static gboolean
displace (GimpDrawable  *drawable,
          gdouble        amount_x,
          gdouble        amount_y,
          gboolean       do_x,
          gboolean       do_y,
          GimpDrawable  *displace_map_x,
          GimpDrawable  *displace_map_y,
          gint           displace_type,
          gint           displace_mode,
          GimpProgress  *progress,
          GError       **error)
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      if (do_x || do_y)
        {
          GeglNode *graph;
          GeglNode *node;
          GeglAbyssPolicy abyss_policy = GEGL_ABYSS_NONE;

          switch (displace_type)
            {
              case 1:
                abyss_policy = GEGL_ABYSS_LOOP;
                break;
              case 2:
                abyss_policy = GEGL_ABYSS_CLAMP;
                break;
              case 3:
                abyss_policy = GEGL_ABYSS_BLACK;
                break;
            }

          node = gegl_node_new_child (NULL,
                                      "operation",     "gegl:displace",
                                      "displace_mode", displace_mode,
                                      "sampler_type",  GEGL_SAMPLER_CUBIC,
                                      "abyss_policy",  abyss_policy,
                                      "amount_x",      amount_x,
                                      "amount_y",      amount_y,
                                      NULL);

          graph = wrap_in_graph (node);

          if (do_x)
            {
              GeglNode *src_node;
              src_node = create_buffer_source_node (graph, displace_map_x);
              gegl_node_connect (src_node, "output", node, "aux");
            }

          if (do_y)
            {
              GeglNode *src_node;
              src_node = create_buffer_source_node (graph, displace_map_y);
              gegl_node_connect (src_node, "output", node, "aux2");
            }

          gimp_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Displace"),
                                         graph);
          g_object_unref (graph);
        }

      return TRUE;
    }
  else
    return FALSE;
}

static gboolean
gaussian_blur (GimpDrawable  *drawable,
               gdouble        horizontal,
               gdouble        vertical,
               gint           method,
               GimpProgress  *progress,
               GError       **error)
{
  if (gimp_pdb_item_is_attached (GIMP_ITEM (drawable), NULL,
                                 GIMP_PDB_ITEM_CONTENT, error) &&
      gimp_pdb_item_is_not_group (GIMP_ITEM (drawable), error))
    {
      GeglNode *node;

      node = gegl_node_new_child (NULL,
                                  "operation",    "gegl:gaussian-blur",
                                  "std-dev-x",    horizontal,
                                  "std-dev-y",    vertical,
                                  "filter",       method,
                                  "abyss-policy", 1,
                                  NULL);

      node = wrap_in_gamma_cast (node, drawable);

      gimp_drawable_apply_operation (drawable, progress,
                                     C_("undo-type", "Gaussian Blur"),
                                     node);
      g_object_unref (node);

      return TRUE;
    }

  return FALSE;
}

static gint
newsprint_color_model (gint colorspace)
{
  switch (colorspace)
    {
    case 0: return 1; /* black on white */
    case 1: return 2; /* rgb */
    case 2: return 3; /* cmyk */
    case 3: return 1; /* black on white */
    }

  return 2;
}

static gint
newsprint_pattern (gint spotfn)
{
  switch (spotfn)
    {
    case 0: return 1; /* circle */
    case 1: return 0; /* line */
    case 2: return 2; /* diamond */
    case 3: return 4; /* ps circle */
    case 4: return 2; /* FIXME postscript diamond */
    }

  return 1;
}

static gdouble
newsprint_angle (gdouble angle)
{
  while (angle > 180.0)
    angle -= 360.0;

  while (angle < -180.0)
    angle += 360.0;

  return angle;
}
CODE

@headers = qw(<cairo.h>
              "libgimpbase/gimpbase.h"
              "libgimpcolor/gimpcolor.h"
              "libgimpconfig/gimpconfig.h"
              "libgimpmath/gimpmath.h"
              "gegl/gimp-babl.h"
              "gegl/gimp-gegl-utils.h"
              "config/gimpcoreconfig.h"
              "core/gimp.h"
              "core/gimpchannel.h"
              "core/gimpcontext.h"
              "core/gimpdrawable-operation.h"
              "core/gimpimage-crop.h"
              "core/gimpimage-resize.h"
              "core/gimpimage-rotate.h"
              "core/gimpimage-undo.h"
              "core/gimppickable.h"
              "core/gimppickable-auto-shrink.h"
              "gimppdberror.h"
              "gimppdb-utils.h"
              "gimp-intl.h");

@procs = qw(plug_in_autocrop
            plug_in_autocrop_layer
            plug_in_bump_map
            plug_in_displace
            plug_in_emboss
            plug_in_gauss
            plug_in_rotate
            plug_in_noisify);

%exports = (app => [@procs], lib => []);

$desc = 'Plug-in Compat';
$doc_title = 'gimpplugincompat';
$doc_short_desc = 'Compatibility for removed plug-ins.';
$doc_long_desc = 'Functions that perform the operation of removed plug-ins using GEGL operations or other GIMP internal functions.';

1;
